sudo: required
services:
  - docker
env:
  global:
    - IMAGE_NAME=bluecompute-inventory
    - RELEASE_NAME=inventory
    - LATEST_TAG=travis-latest
stages:
  - build
  - test
jobs:
  include:
    - stage: build
      script:
      # Compose Full Docker Image Name
      - if [ -n "$DOCKER_ORG"]; then FULL_IMAGE_NAME=${DOCKER_ORG}/${IMAGE_NAME}; else FULL_IMAGE_NAME=${DOCKER_USERNAME}/${IMAGE_NAME}; fi
      # Build Docker image
      - docker build -t "${FULL_IMAGE_NAME}:${LATEST_TAG}" .
      # Docker Login
      - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
      # Create Image Tag from chart version
      - VERSION_TAG="travis-$(cat chart/inventory/Chart.yaml | grep version | awk '{print $2}')"
      # Tag image with chart version tag
      - docker tag "${FULL_IMAGE_NAME}:${LATEST_TAG}" "${FULL_IMAGE_NAME}:${VERSION_TAG}"
      # Push image to share with test and deploy stages
      - docker push "${FULL_IMAGE_NAME}:${LATEST_TAG}" && docker push "${FULL_IMAGE_NAME}:${VERSION_TAG}"
    - stage: test
      services:
      - mysql
      before_script:
      # Compose Full Docker Image Name
      - if [ -n "$DOCKER_ORG"]; then FULL_IMAGE_NAME=${DOCKER_ORG}/${IMAGE_NAME}; else FULL_IMAGE_NAME=${DOCKER_USERNAME}/${IMAGE_NAME}; fi
      # Wait for MySQL to start, then load it with inventory data
      - cd scripts; ./load_data.sh root "" 127.0.0.1 3306 inventorydb; cd ..
      # Start Inventory Container and Connect to local MySQL Service
      - docker run --net=host --name inventory -d -p 8080:8080 -e MYSQL_URI="mysql://root@127.0.0.1:3306/inventorydb" "${FULL_IMAGE_NAME}:${LATEST_TAG}"
      # Wait for the Inventory container to start accepting connections
      - sleep 25
      script:
      # Check that the Inventory container is running
      - docker ps
      # Check logs to see if it started properly
      - docker logs inventory
      # Run Inventory API Test
      # TODO: Test more APIs, perhaps with a separate script
      - curl http://127.0.0.1:8080/micro/inventory
    - stage: deploy
      env:
      - CHANGE_MINIKUBE_NONE_USER=true
      before_script:
      # Install nsenter, which is needed for minikube to work
      - bash scripts/install_nsenter.sh 
      # Download kubectl, which is a requirement for using minikube.
      - curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/
      # Download minikube.
      - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.25.2/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/
      - sudo minikube start --vm-driver=none --kubernetes-version=v1.9.0
      # Fix the kubectl context, as it's often stale.
      - minikube update-context
      # Getting ip for testing
      - minikube ip
      # Wait for Minikube to be up and ready.
      - JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'; until kubectl get nodes -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do sleep 1; done
      # Download Helm CLI
      - curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get > get_helm.sh && chmod 700 get_helm.sh && ./get_helm.sh && rm get_helm.sh
      # Create Tiller Service Account
      - kubectl -n kube-system create sa tiller && kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
      # Install Helm on Minikube
      - helm init --service-account tiller
      # Wait for helm to be ready
      - until helm list; do echo "waiting for helm to be ready"; sleep 1; done
      script:
      # Compose Full Docker Image Name
      - if [ -n "$DOCKER_ORG"]; then FULL_IMAGE_NAME=${DOCKER_ORG}/${IMAGE_NAME}; else FULL_IMAGE_NAME=${DOCKER_USERNAME}/${IMAGE_NAME}; fi
      # Get cluster info
      - kubectl cluster-info
      # Download Inventory chart dependencies (MySQL)
      - cd chart/inventory; helm dependency update; cd ../..
      # helm lint
      - helm lint chart/inventory
      # helm package
      - helm package chart/inventory
      # helm install Inventory from packaged chart
      - CHART_VERSION="$(cat chart/inventory/Chart.yaml | grep version | awk '{print $2}')"
      - VERSION_TAG="travis-${CHART_VERSION}"
      - helm upgrade --install inventory --set service.type=NodePort,image.repository="${FULL_IMAGE_NAME}",image.tag="${VERSION_TAG}",dataloader.image.tag="test" inventory-${CHART_VERSION}.tgz
      # Wait for Inventory to be ready
      - kubectl get deployments ${RELEASE_NAME}-inventory -o yaml
      - READY=$(kubectl get deployments ${RELEASE_NAME}-inventory -o yaml | grep "readyReplicas" | awk '{print $2}')
      - echo $READY
      - until [ -n "$READY" ] && [ ${READY} -ge 1 ]; do READY=$(kubectl get deployments ${RELEASE_NAME}-inventory -o yaml | grep "readyReplicas" | awk '{print $2}'); kubectl get deployments -o wide; echo "Waiting for inventory to be ready"; sleep 10; done
      # Wait for Inventory deployment to start accepting connections
      - sleep 35
      # Run Inventory API Test
      - NODE_PORT=$(kubectl get service ${RELEASE_NAME}-inventory -o=jsonpath='{.spec.ports[0].nodePort}')
      - curl http://$(minikube ip):${NODE_PORT}/micro/inventory